<script src="../immutable/dist/immutable.min.js"></script>
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../vaadin-combo-box/vaadin-combo-box-light.html">
<link rel="import" href="../flag-cc/flag-cc.html">

<!--
Automatic representation of a scalar value as Polymer Elements (Iron and Paper) – in either read-only or editing mode.

‹data-scalars› elements consume an immutable data egg data structure and produce suitable Polymer elements to represent that value. The data egg is a simple structure, which contains the scalar value, its type and logical formatting hints.

Designed to work hand-in-hand with data nuggets data structures delivered by ‹data-pipes›, although both can be used independently.

Example of usage:

  <data-scalars data="{{dataEgg}}"></data-scalars>
-->
<dom-module id="custom-vaadin-combo-box-item" theme-for="vaadin-combo-box-item">
  <template>
    <style>
      :host {
        padding: 0;
        margin: 0;
        max-height: 32px;
      }
      [part="content"] {
        padding: 0;
        margin: 0;
      }
      :host::before {
        display: none !important; /* Remove the blue-checkmark */
      }
    </style>
  </template>
</dom-module>

<dom-module id="data-scalars">
  <template>
    <style>
      :host {
        display: block;
        @apply --layout-flex;
        @apply --layout-horizontal;
        padding: 0px;
      }

      div.content {
        border: 1px dotted transparent;
        font-size: 12px;
        color: inherit;
        width: 100%;
        display: flex;
        position: relative;
        box-sizing: border-box;
        align-items: center;
      }

      div.content[editing] {
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px dotted gray;
      }

      div.content .element {
        background-color: transparent;
        width: 100%;
      }
      div.content:not([editing]) .element.number {
        text-align: right;
      }
      div.content .element.financial {
        /** Nothing yet */
      }


      /** TODO: check this */
      div[hidden]{
        display: none;
      }

      select,
      select option,
      input,
      iron-input,
      vaadin-combo-box-light {
        color: inherit;
        font-family: inherit;
        width: 100%;
        font-weight: inherit;
        font-size: inherit;
        padding: 0px;
        display: flex;
        border: none;
        box-sizing: border-box;
        outline: none;
      }


      /** Hack to remove the forced padding from the browser */
      select,
      input {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        padding: 0px;
      }

      vaadin-combo-box-light {
        min-width: 100px !important;
      }

      /** Turn off input[type=number] arrows/spiner */
      input[type=number]::-webkit-inner-spin-button,
      input[type=number]::-webkit-outer-spin-button {
        -webkit-appearance: none;
      }


      /** Used for vaadin dropdown where the inner input shouldn't choose its background-color */
      iron-input input {
        background-color: transparent;
      }

      div.content[disabled],
      input[disabled],
      select[disabled] {
        background: transparent;
        border: none !important;
      }

      div.content.error {
        border: 1px solid rgb(255, 41, 41);
        background-color: rgba(248, 183, 183, 0.5);
      }
      div.content[disabled].error {
        border: 1px solid transparent;
      }

      iron-icon {
        min-width: 20px;
        min-height: 20px;
      }

      .flag-cc-wrapper {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1px;
      }
      flag-cc {
        width: 100%;
        height: 100%;
      }

    </style>
    <div id="scalar" class$="content [[_getErrorClass(data)]]" editing$="[[editing]]"
         disabled$="[[_disabled]]" title="[[_title]]">

      <!-- Icon -->
      <template is="dom-if" if="[[_isDataOfType(data, 'icon')]]">
        <template is="dom-if" if="[[editing]]">
          <input
              class$="input element [[_elementType]] [[_elementVariant]]"
              value$="[[_value]]"
              title="[[_title]]"
              disabled="[[_disabled]]"
              placeholder="[[placeholder]]"
              on-change="_onChange"
              on-keyup="_onKeyup"
              on-keydown="_onKeydown"
          >
        </template>
        <template is="dom-if" if="[[!editing]]">
          <template is="dom-if" if="[[__equals(_elementVariant, 'default')]]">
            <iron-icon icon$="[[_getIconName(_suggestionsByLabel, _value)]]"></iron-icon>
          </template>
          <template is="dom-if" if="[[__equals(_elementVariant, 'flag')]]">
            <div class="flag-cc-wrapper">
              <flag-cc currency="[[_value]]"></flag-cc>
            </div>
          </template>
        </template>
      </template>

      <!-- Text value -->
      <template is="dom-if" if="[[_shouldShowValue(data)]]">
        <span style="display: none">[[_value]]</span> <!-- In order to correctly us the DOM sort (eg: vaadin grid) -->
        <template is="dom-if" if="[[!editing]]">
          <div style="[[_getTextStyle(data, metaData, _value)]]" title="[[_computeTitle(data)]]" class$="element [[_elementType]] [[_elementVariant]]">
            [[_formatValue(data, _value, _suggestions)]]
          </div>
        </template>
      </template>

      <!-- EDITING MODE -->
      <template is="dom-if" if="[[editing]]">

        <!-- Editing primitive value -->
        <template is="dom-if" if="[[_isDataOfTypePrimitive(data)]]">
          <template is="dom-if" if="[[!_disabled]]">
            <input
                class$="input element [[_elementType]] [[_elementVariant]]"
                type$="[[_getType(data)]]"
                value$="[[_value]]"
                title="[[_title]]"
                disabled="[[_disabled]]"
                placeholder="[[placeholder]]"
                on-change="_onChange"
                on-keyup="_onKeyup"
                on-keydown="_onKeydown"
            >
          </template>
          <template is="dom-if" if="[[_disabled]]">
            [[_formatValue(data, _value, _suggestions)]]
          </template>
        </template>

        <!-- Editing date and timestamp value -->
        <template is="dom-if" if="[[_isDataOfTypeDate(data)]]">
          <template is="dom-if" if="[[!_disabled]]">
            <input
                class$="input element [[_elementType]] [[_elementVariant]]"
                type$="[[_parseHTMLDateType(data)]]"
                value$="[[_formatDatetime(data, _value, 'true')]]"
                title="[[_title]]"
                disabled="[[_disabled]]"
                placeholder="[[placeholder]]"
                on-change="_onChange"
                on-keyup="_onKeyup"
                on-keydown="_onKeydown"
            >
          </template>
          <template is="dom-if" if="[[_disabled]]">
            [[_formatValue(data, _value, _suggestions)]]
          </template>
        </template>

        <!-- Editing dropdown -->
        <template is="dom-if" if="[[_isDataOfType(data, 'dropdown')]]">
          <template is="dom-if" if="[[!_disabled]]">
            <vaadin-combo-box-light
              class$="input element dropdown [[_elementType]] [[_elementVariant]]"
              placeholder="[[placeholder]]"
              items="[[_suggestions]]"
              value="[[_getLabelFromValue(_suggestions, _value)]]"
              attr-for-value="bind-value"
              disabled="[[_disabled]]"
              allow-custom-value="[[_allowCustomValue]]"
              selected-item="{{_dropdownSelectedItem}}"
              >
              <template>
                <div style="font-size: 10px; font-family:'Roboto';">[[item.label]] ([[item.value]])</div>
              </template>
              <iron-input>
                <input
                    placeholder="[[placeholder]]"
                    disabled$="[[_disabled]]"
                    on-keyup="_onKeyup"
                    on-keydown="_onKeydown"
                >
              </iron-input>
            </vaadin-combo-box-light>
          </template>
        </template>

        <!-- Editing checkbox -->
        <template is="dom-if" if="[[_isDataOfType(data, 'checkbox')]]">
          <template is="dom-if" if="[[!_disabled]]">
            <select
                class$="input element checkbox [[_elementType]] [[_elementVariant]]"
                disabled="[[_disabled]]"
                on-change="_onTick"
                value="[[_value]]"
                on-keyup="_onKeyup"
            >
              <option>unset</option>
              <option value=true>true</option>
              <option value=false>false</option>
            </select>
          </template>
          <template is="dom-if" if="[[_disabled]]">
            [[_value]]
          </template>
        </template>
      </template>
    </div>
  </template>

  <script>
    /* jshint esversion:6, asi:true */
    /**
     * `data-scalars`
     * Automatic representation of a scalar value
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class DataScalars extends Polymer.Element {
      static get is() { return 'data-scalars'; }
      static get properties() {
        return {
          /**
           * The given `dataEgg`. A `dataEgg` is one element of the `dataNugget`.
           * Example:
           *
           * ```
           *    dataEgg = {value: …, schema: …, format: … [, metadata: …]}
           *
           *    schema = {
           *      editing: true|false,
           *      type:       text|number|date|boolean|dropdown,
           *      hidden:     true|false,
           *      disabled:   true|false
           *      variant:    ... see bellow ...,
           *      decimals:   a positive number
           *
           *    Variants:
           *      if the type is text:   default
           *      if the type is date:   default
           *      if the type is number: financial|percentage|default;
           * ```
           */
          data: {
            type: Object,
            notify: true
          },


          /* Name of the data-scalar */
          name: {
            type: String,
          },

          /** Defines if the data-scalar is in editing mode or not */
          editing: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true
          },

          /** The new value that is set while editing */
          newValue: {
            type: String,
            notify: true
          },

          /**
           * The input field will be disabled when the editing mode is
           * activated
           */
          disabled: {
            type: Boolean,
            notify: true,
            reflectToAttribute: true,
          },
          _disabled: {
            type: Boolean,
            notify: true,
            observer: "_disabledChanged",
            computed: "_computeDisabled(data, disabled)"
          },

          /** Placeholder for the field */
          placeholder: {
            type: String
          },

          /** Internal computed element type */
          _elementType: {
            type: String,
            value: "text",
            computed: "_computeElementType(data)"
          },

          /** Internal computed element variant type */
          _elementVariant: {
            type: String,
            value: "default",
            computed: "_computeElementVariant(data)"
          },

          /**
           * Used to know if the dropdown can have custom values.
           * To disable custom values set the variant to "no-custom-value".
           */
          _allowCustomValue: {
            type: Boolean,
            value: true,
            computed: "_computeAllowCustomValue(_elementType, _elementVariant)"
          },


          /**
           * Suggestions that are computed from the schema
           * eg: [{label: …, value:…}, …]
           */
          _suggestions: {
            type: Array,
            computed: "_computeSuggestions( data)"
          },

          /**
           * Suggestions object structured by `label`
           * eg: {"label1": "value1", "label2": "value2", …}
           */
          _suggestionsByLabel: {
            type: Object,
            computed: "_computeSuggestionsByLabel( _suggestions)"
          },

          /** Internal computed value */
          _value: {
            type: String,
            computed: "_computeValue( data)"
          },

          /** Internal computed tooltip title */
          _title: {
            type: String,
            computed: "_computeTitle(data, title)"
          },

          __previousOnChangeValue: {
            type: String,
            value: ""
          },

          _dropdownSelectedItem: {
            type: Object,
            observer: "_dropdownSelectedItemChanged"
          },

          metaData: Object
        };
      }

      ready() {
        super.ready();
      }

      /** Compute the `_value` and update its input field to make sure it is correct */
      _computeValue( data){
        if(!data){return}
        var value = data.get("value");

        // Translate undefined to empty string
        if(value == undefined) { value = ""; }

        this._forceValue(value);

        return value;
      }

      /** Computes the disable option from the schema */
      _computeDisabled( data, disabled) {
        if(disabled != undefined) {
          return disabled;
        }
        if(data.get("schema")){
          return data.get("schema").get("disabled") || false;
        }
        return false;
      }

      /** Computes the suggestions from the schema */
      _computeSuggestions( data){
        if(!data){ return}
        if(data.get("schema") && data.get("schema").get("suggestions")){
          return data.get("schema").get("suggestions").toJS()
        }
      }

      /** Computes the suggestions scrutured by 'label' */
      _computeSuggestionsByLabel( _suggestions) {
        var result = {};
        if(_suggestions) {
          _suggestions.forEach( (sug) => {
            result[sug.label] = sug.value;
          });
        }
        return result;
      }

      /**
        * Computes the title that is display when hovering a field. If there is a specific error
        * in the schema, the error will be shown.
        */
      _computeTitle(data, title){
        if( title != undefined){ return title; }
        if( !data) {return undefined; }
        if( !data.get("error")){ return data.get("value"); }
        return "Error: "+data.get("error");
      }

      /** Computes the element type from the schema */
      _computeElementType( data) {
        return this._getType( data);
      }

      /** Computes the element variant type from the schema */
      _computeElementVariant( data) {
        return this._getVariant( data);
      }

      _computeAllowCustomValue( type, variant) {
        return type == "dropdown" && variant != "no-custom-value" ? true : false;
      }

      /** Helpers */

      /** When `disabled` is changed, update the value to make sure it's correct in the input field */
      _disabledChanged(disabled){
        if(!this.data){return;}
        if(this._value) {
          // Make sure the value is updated when editing
          this._computeValue(this.data);
        }
      }

      /* Make sure that the user edition is deleted and replaced by the default value */
      _forceValue(value){
        var type = this._getType(this.data)
        var scalar = this.$.scalar;
        if(scalar) {
          var input = scalar.querySelector(".input");
          if(input){
            input.value = value;
          }
        }
        this._value = value;

        // Make sure to detect futher changes. Reseting previous change.
        // TODO: this should be in an observer when the `editing` attribute
        // changes.
        if(type == "dropdown"){
          // this is because the default vaadin value is an empty string instead of undefined.
          // Thus, going to the 'edit' mode will trigger a change from undefined to empty string.
          // We do not want to trigger the initial on-change event.
          this.__previousOnChangeValue = "";
        } else { this.__previousOnChangeValue = undefined; }
      }

      /** If there is an error, the `error` class is returned to the input field */
      _getErrorClass(data){
        if(!data || !data.get("error")){return;}
        if(data.get("error")){
          return "error"
        }
      }

      /** Dispatch the 'change' event with the name and value of the component */
      _dispatchChangeEvent(value) {
        var event = new CustomEvent('change', {'detail': {name: this.name, value: value}})
        this.dispatchEvent(event);
      }

      /**
        * Dispatch a custom event 'change' when the input changes.
        * The event carries the name and value of the input in its details.
        *   {'detail': {name: "the name", value: "the value"}}
        */
      _onChange(e){
        var value = e.currentTarget.value;
        if(e.currentTarget.type == "datetime-local"){
          value = value.replace("T", " ");
        }

        // We need to make sure that the onChange was triggered twice.
        // After the user has finished doing an edition, the event is resent
        // to notify about the latest value.
        if(this.__previousOnChangeValue != value){
          this._dispatchChangeEvent( value)
          this.__previousOnChangeValue = value;
        }
        this.newValue = value;
      }

      _dropdownSelectedItemChanged(_dropdownSelectedItem) {
        if(_dropdownSelectedItem) {
          var e = { currentTarget: { value: _dropdownSelectedItem.value}};
          this._onChange(e);
        }
      }

      _onKeyup(e) {
        this._onChange(e); // Make sure we capture the last onchange event
      }

      /**
       * Dispatch an event when some special keys are used.
       * Eg:
       *     - Escape key will dispatch the 'cancel' event
       *     - Enter key will dispatch the 'validate' event
       */
      _onKeydown(e) {
        if(e.ctrlKey && e.keyCode == 13) {
          e.stopPropagation();
          e.preventDefault();
          var event = new Event('validate');
          this.dispatchEvent(event);
        } else if (e.code == "Escape") {
          var event = new Event('cancel');
          this.dispatchEvent(event);
        }
      }

      /** Dispatch a custom event 'change' when the checkbox attribut has changed */
      _onTick(e){
        var elem = e.currentTarget;
        var value = elem.options[elem.selectedIndex].value;
        var checked = "";
        if(value == "true"){checked = true;}
        else if(value == "false"){checked = false;}
        this._dispatchChangeEvent( checked);
        this.newValue = checked;
      }

      /** Retrieves the type from the schema */
      _getType(data){
        if(data && data.get("schema") && data.get("schema").get("type")){
          return data.get("schema").get("type").toLowerCase();
        } else {
          return 'text';
        }
      }

      /** Retrieves the style from the schema */
      _getStyle(data, metaData){
        if(data && data.get("schema") && data.get("schema").get("style")){
          var style = data.get("schema").get("style");
          if(typeof style === "function") {
            style = style(data, metaData);
          }
          return style;
        } else {
          return '';
        }
      }

      /** Return the parsed HTML date type */
      _parseHTMLDateType(data) {
        var type = this._getType(data);
        if(type == 'date'){
          return 'date';
        } else if( ['datetime', 'datetime-local', 'timestamp'].indexOf(type) > -1){
          return 'datetime-local';
        }
        return 'text';
      }

      /** Returns the schema type variant */
      _getVariant(data) {
        if(data && data.get("schema") && data.get("schema").get("variant")){
          return  data.get("schema").get("variant").toLowerCase();
        } else {
          return 'default';
        }
      }

      /** Returns the schema decimals information */
      _getDecimals(data) {
        if(data && data.get("schema") && data.get("schema").get("decimals")){
          return data.get("schema").get("decimals");
        } else {
          return undefined;
        }
      }

      /**
        * Checks if the type, given from the schema, is an HTML primitive type.
        * This is used to know if we can use an HTML tag instead of a custom component
        * to present the data value.
        */
      _isDataOfTypePrimitive(data){
        var primitiveTypes = ['text', 'number'];
        var type = this._getType(data);
        if(type) {
          return primitiveTypes.indexOf( type) > -1;
        } else {
          return true;
        }
      }

      /** Returns true if the data type is a `date` type */
      _isDataOfTypeDate(data) {
        var dateTypes = ['date', 'datetime', 'datetime-local', 'timestamp'];
        var type = this._getType(data);
        return dateTypes.indexOf(type) > -1;
      }

      /**
        * Returns true if the data is of type `elType`.
        * By default and if the type is not specified, it will return true as if `elType` == 'text'
        */
      _isDataOfType(data, typeToCheck){
        var type = this._getType(data);
        if( ["bool", "checkbox", "boolean"].indexOf(type) > -1){
          type = "checkbox";
        }

        if(type){
          return type == typeToCheck;
        } else {
          return typeToCheck == 'text';
        }
      }

      /**
       * Should display the data value. Eg: the icon should not display its string
       */
      _shouldShowValue(data) {
        var type = this._getType(data);
        if (type != "icon") {
          return true;
        }
        return false;
      }

      _getIconName(_suggestionsByLabel, _value) {
        var icon = _value;
        if(_suggestionsByLabel && _suggestionsByLabel[_value]) {
          icon = _suggestionsByLabel[_value];
        }
        return icon;
      }

      _getFlagName(_suggestionsByLabel, _value){
        var flag = _value;
        if(_suggestionsByLabel && _suggestionsByLabel[_value]) {
          flag = _suggestionsByLabel[_value];
        }
        return flag;
      }

      _formatValue(data, _value, _suggestions){
        var value = this._getLabelFromValue(_suggestions, _value);
        var type = this._getType(data);
        var variant = this._getVariant(data);
        if( type == 'number') {
          var decimals = this._getDecimals(data);
          switch(variant){
            case 'financial':
              return this._financialNumber(value, decimals);
            case 'financial-locale':
              return this._financialNumber(value, decimals, true);
            case 'percentage':
              return this._percentageNumber(value, decimals);
            default:
              return value;
          }
        } else if( ['date', 'datetime-local', 'timestamp'].indexOf(type) > -1 && _value) {
          return this._formatDatetime(data, _value);
        }
        return value;
      }

      _formatDatetime(data, _value, html=false){
        if(_value){
          var type = this._getType(data);
          var date = new Date(_value);
          var month = (date.getMonth()+1)+"";
          month = month.length > 1 ? month : '0'+month;
          var day = (date.getDate()+"").length > 1 ? date.getDate() : '0'+date.getDate();
          var year = date.getFullYear();
          var hours = (date.getHours()+"").length > 1 ? (date.getHours()) : '0'+date.getHours();
          var minutes = (date.getMinutes()+"").length > 1 ? (date.getMinutes()) : '0'+date.getMinutes();
          var string = html ? year+"-"+month+"-"+day : day+"."+month+"."+year;
          if( type != 'date') {
            string += html ? "T" : " ";
            string += hours+":"+minutes;
          }
        }
        return string;
      }

      _financialNumber(x, decimals=2, isLocale) {
        if(x == undefined || x == ""){ return x; }
        x = Math.round(x * Math.pow(10, decimals)) / Math.pow(10, decimals) // Round to the decimals number. This avoids having 19999.9999999 formatted to 19'999.00 which is wrong
        if(isLocale){
          return x.toLocaleString(undefined, {minimumFractionDigits: decimals});
        }
        var parts = x.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, "'");
        parts[1] = (parseFloat("0."+parts[1]).toFixed(decimals).split("."))[1] || "00";
        return parts.join(".");
      }

      _percentageNumber(x, decimals=2) {
        return x !== undefined ? (parseFloat(x) * 100).toFixed(decimals) + " %" : x;
      }

      __equals(a, b) {
        return a == b;
      }

      /**
       * Retrieves the suggestion label from the value if exists.
       * Else it returns the value
       */
      _getLabelFromValue(_suggestions, _value) {
        var label = _value;
        if(_suggestions){
          _suggestions.forEach( (s) => {
            if(s.value == _value) { label = s.label; }
          });
        }
        return label;
      }

      _getTextStyle(data, metaData, _value){
        if(_value == undefined){ return ""; }
        var style = this._getStyle(data, metaData);
        var type = this._getType(data);
        var variant = this._getVariant(data);
        if(type == "number" && ["financial", "financial-locale"].indexOf(variant) > -1){
          if(_value > 0){
            style = "color: yellowgreen;"+style;
          } else if( _value < 0) {
            style = "color: indianred;"+style;
          }
        }
        return style;
      }

      empty(){
        this.data = this.data.set("value", "");
        this._forceValue("");
      }

      getValue() {
        return this._value;
      }
    }
    window.customElements.define(DataScalars.is, DataScalars);
  </script>
</dom-module>
